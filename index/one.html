<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>es6复习</title>
</head>
<body>
    <script>

        /*************************************************************************************************************************************/

            // const person = {
            //     name:'jm',
            //     age:20
            // }
            // const persons = Object.freeze(person) // es5里面的不允许改变对象里面的属性！
            
        /*************************************************************************************************************************************/

            // let const 理解
            // var name = 'jm' // window 有全局的name属性
            // 为了让name 私有化 ， {es5}里面增加自执行函数
            // (function () {
            //     var name = 'jm'
            // })();

        /*************************************************************************************************************************************/

            // var arr=[{"id":1,"value":1},{"id":2,"value":2},{"id":3,"value":3}]
            // var arr1=[{"id":1,"value":1},{"id":4,"value":4},{"id":5,"value":5}]
            // //带键值对的用 for in
            // for(var i in arr){
            //         for(var k in arr1){
            //         if(arr[i].id == arr1[k].id){
            //             arr1.splice(k,1)
            //             arr.splice(i,1)
            //         }
            //     }
            // }
            // kkkarr = [...arr1,...arr]
            // console.log(kkkarr);

        /*************************************************************************************************************************************/
        
            // 简单分析 this 指向问题

            //  箭头函数  是没有 this 值得 简单说就是他在执行的时候继承了  父作用域的 this 定义的时候就已经被指定了this
            //  不会因为被谁调用而指向谁了而改变了

            // const student = {
            //     name:'xiaoMing',
            //     names:['hong','lan','huang',]
            //     Method:function () {
            //         this.names.map(boby=>{
            //             console.log(`${this.name}+++++${boby}`)
            //         })
            //     }
                
            // }

            
            // const student = {
            //     name:'xiaoMing',
            //     names:['hong','lan','huang',],
            //     Method:function () {
            //         this.names.map(function(boby){
            //             //  独立函数情况下，在没有被对象调用，或者bind call 改变的时候 this 的指向为win 严格模式下为un
            //             //  通常情况下可以单独绑定this  改变 this 指向问题
            //             console.log(`${this.name}+++++${boby}`)
            //         })
            //     }
                
            // }

            // student.Method()

            // 1、作为构造函数，或一个方法需要绑定到对象上
            // 2、当需要真正的this的时候
            // 3、当你要使用 arguments 参数的时候
            


        /*************************************************************************************************************************************/

            // 函数的默认值

            // 默认参数的   注意  func(a=5,b=1 ){}   调用的 时候要穿un

            // var str = "       Runoob        ";
            // alert(str.trim());   Runoob

        /*************************************************************************************************************************************/
        
            // // 字符串 格式
            // const strings =  '121213131123331'
            // strings.startsWith() // 开头 查找   parameter2 可以定义在第几位开始
            // strings.endsWith()   // 结尾 查找   parameter2 可以定义在第几位开始
            // strings.includes()   // 查找是否存在 你所查找的字符串，直接返回布尔值
            // strings.repeat()     // 复制调用的 字符串

         /*************************************************************************************************************************************/
          
            // 循环 for ... of ...

            const newArr = ['小明','小兰','小绿'] 
            const newArr1 = [{name:'小明',age:18},{name:'小兰',age:45},{name:'小绿',age:18}] 


            // newArr.forEach(name=>{})  // forEach 循环不能被打断 break continue

            
            // newArr.describe='asdas'  // for in 也能把 后增加的属性也会循环出来。

            // Array.prototype.newArr = function(){ } // for in 也能把 数组原型也会循环出来。

            // for (let key in newArr) {console.log(newArr[key])} // 

            // for (let key of newArr) {console.log(key)} // 属性值 而不是下标  for ... of ...  可以解决 for ... in ... 刚出现的问题

            // for( let [index,name] of newArr.entries() ){  
            //     // entries() 方法返回一个数组的迭代对象，该对象包含数组的键值对 (key/value)。
            //     // 根据 entries 方法返回的数据接口  就可以使用 数组的解构方法 同时取到所需的值
            //     console.log(index,name)
            // }

         /*************************************************************************************************************************************/
           
            // 数组的 新增方法   
            
            // Array.from() arguments || 字符串 || dom 节点类数组 转换成真正的数组   
            
            // Array.of() 主要弥补了 new Array() 构造函数的不足 ，  Array.of() 传入 一个参数 也会返回当前参数的数组
           
            // .find()  
            // const newArr2 = newArr1.find((element,index,array)=>{
            //         if (element.age === 18) {
            //             return 
            //         }
            //     }
            // ) 
            // console.log(newArr2,newArr1)  // find() 对于空数组，函数是不会执行的 // find() 并没有改变数组的原始值。
            // 注意  警告：：：：： 这个方法  只会返回  数组中第一个符合的条件的 元素 不会在 向下 执行了  这也是和  .filter()主要的  区别  返回全部结果仍然是数组。
          
            // .findIndex 返回 下标的 方法
            // const newArr3 = newArr1.findIndex((element,index,array)=>{
            //         if (element.age === 18) {
            //             return 
            //         }
            //     })
            // console.log(newArr3,newArr1)  
            // 注意  警告：：：：： 这个方法  只会返回  数组中第一个符合的条件的 元素 不会在 向下 执行了

            //  const newArr4 =  newArr.some(fruit =>fruit.age >0)  // 有一个 满足测试函数 返回  true
            //  newArr.every()   //  所有元素都 满足测试函数 返回  true
        
            // Array.prototype.includes  方法返回一个布尔值，表示某个数组是否包含给定的值，
            // [1, 2, 3].includes(2)     // true        [1, 2, NaN].includes(NaN) // true
            // 该方法的第二个参数表示搜索的起始位置，默认为0。如果第二个参数为负数，则表示倒数的位置，如果这时它大于数组长度（比如第二个参数为-4，但数组长度为3），则会重置为从0开始。
            
            const flatArr = ['小明','小兰','小绿',['1','2',['4','5']]] 

            // .flat()  // 用于将嵌套的数组“拉平”，变成一维的数组。该方法返回一个新数组，对原数据没有影响
            const flatArr1 = flatArr.flat()
            const flatArr2 = flatArr.flat(2)
            console.log(flatArr1,flatArr2,flatArr)

         /*************************************************************************************************************************************/
         /*************************************************************************************************************************************/
         /*************************************************************************************************************************************/
         /*************************************************************************************************************************************/
         /*************************************************************************************************************************************/
         /*************************************************************************************************************************************/
         
         
      
    </script>
</body>
</html>