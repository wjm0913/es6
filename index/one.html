<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <meta http-equiv="X-UA-Compatible" content="ie=edge">
    <title>es6复习</title>
</head>
<body>
    <script>

        /*************************************************************************************************************************************/

        // const person = {
        //     name:'jm',
        //     age:20
        // }
        // const persons = Object.freeze(person) // es5里面的不允许改变对象里面的属性！
        
        /*************************************************************************************************************************************/

        // let const 理解
        // var name = 'jm' // window 有全局的name属性
        // 为了让name 私有化 ， {es5}里面增加自执行函数
        // (function () {
        //     var name = 'jm'
        // })();

        /*************************************************************************************************************************************/

        // var arr=[{"id":1,"value":1},{"id":2,"value":2},{"id":3,"value":3}]
        // var arr1=[{"id":1,"value":1},{"id":4,"value":4},{"id":5,"value":5}]
        // //带键值对的用 for in
        // for(var i in arr){
        //         for(var k in arr1){
        //         if(arr[i].id == arr1[k].id){
        //             arr1.splice(k,1)
        //             arr.splice(i,1)
        //         }
        //     }
        // }
        // kkkarr = [...arr1,...arr]
        // console.log(kkkarr);

        /*************************************************************************************************************************************/
        
        // 简单分析 this 指向问题

        //  箭头函数  是没有 this 值得 简单说就是他在执行的时候继承了  父作用域的 this 定义的时候就已经被指定了this
        //  不会因为被谁调用而指向谁了而改变了

        // const student = {
        //     name:'xiaoMing',
        //     names:['hong','lan','huang',]
        //     Method:function () {
        //         this.names.map(boby=>{
        //             console.log(`${this.name}+++++${boby}`)
        //         })
        //     }
               
        // }

        
        // const student = {
        //     name:'xiaoMing',
        //     names:['hong','lan','huang',],
        //     Method:function () {
        //         this.names.map(function(boby){
        //             //  独立函数情况下，在没有被对象调用，或者bind call 改变的时候 this 的指向为win 严格模式下为un
        //             //  通常情况下可以单独绑定this  改变 this 指向问题
        //             console.log(`${this.name}+++++${boby}`)
        //         })
        //     }
               
        // }

        // student.Method()

        // 1、作为构造函数，或一个方法需要绑定到对象上
        // 2、当需要真正的this的时候
        // 3、当你要使用 arguments 参数的时候
        


        /*************************************************************************************************************************************/

        // 函数的默认值

        // 默认参数的   注意  func(a=5,b=1 ){}   调用的 时候要穿un

        // var str = "       Runoob        ";
        // alert(str.trim());   Runoob

        /*************************************************************************************************************************************/
        
        // // 字符串 格式
        // const strings =  '121213131123331'
        // strings.startsWith() // 开头 查找   parameter2 可以定义在第几位开始
        // strings.endsWith()   // 结尾 查找   parameter2 可以定义在第几位开始
        // strings.includes()   // 查找是否存在 你所查找的字符串，直接返回布尔值
        // strings.repeat()     // 复制调用的 字符串

         /*************************************************************************************************************************************/
         
         
      
    </script>
</body>
</html>